<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Niveau 2 - Plateformer</title>
<style>
html, body { margin: 0; height: 100%; overflow: hidden; background: #222; font-family: sans-serif; }
#instructions {
  position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
  color: #fff; text-align: center; font-size: 16px;
}
#papCounter {
  position: absolute; top: 40px; left: 10px; color: #fff; font-size: 18px;
}
#finishText {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  color: #fff; font-size: 32px; display:none;
}
#introText {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  text-align: center; font-size: 20px; max-width: 600px;
}
</style>
</head>
<body>

<div id="papCounter">Pap: 0</div>
<div id="finishText">Bravo, tu as fini le niveau !</div>
<div id="introText">
  Bien joué ! Maintenant récupère tous les papillons pour finir ce niveau.<br>
  <small>Appuye sur Entrée pour commencer</small>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.121.1/build/three.module.js';
import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/loaders/GLTFLoader.js';

let scene, camera, renderer, clock = new THREE.Clock();
let player, mixer;
let keys = { z:false, q:false, s:false, d:false };
let velocityY = 0, gravity = -0.005, canJump = false;
let gameStarted = false; // bloque le mouvement jusqu'à Enter

const moveSpeed = 0.08;
const playerHeight = 0.3 * 0.3; 

// Plateformes et pap
let platforms = [];
let paps = [];
let collected = 0;

const papCounter = document.getElementById('papCounter');
const finishText = document.getElementById('finishText');
const introText = document.getElementById('introText');

init();
animate();

function init(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  // Lumières
  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
  hemiLight.position.set(0,200,0);
  scene.add(hemiLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(100,100,100);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 2048;
  dirLight.shadow.mapSize.height = 2048;
  scene.add(dirLight);

  // Caméra
  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0,2,5);

  // Renderer
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  // Sol
  const loaderGrass = new THREE.TextureLoader();
  const groundTexture = loaderGrass.load('./textures/grass.jpg');
  groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
  groundTexture.repeat.set(20,20);
  const plane = new THREE.Mesh(
    new THREE.PlaneGeometry(100,100),
    new THREE.MeshStandardMaterial({map:groundTexture})
  );
  plane.rotation.x = -Math.PI/2;
  plane.receiveShadow = true;
  scene.add(plane);

  // Nuages
  const cloudTex = loaderGrass.load('./textures/clouds.png');
  cloudTex.encoding = THREE.sRGBEncoding;
  const cloudMaterial = new THREE.MeshBasicMaterial({map:cloudTex, transparent:true, side:THREE.DoubleSide});
  for(let i=0;i<10;i++){
    const cloudGeo = new THREE.PlaneGeometry(15,8);
    const cloud = new THREE.Mesh(cloudGeo, cloudMaterial.clone());
    cloud.position.set(Math.random()*200-100, Math.random()*20, Math.random()*-100);
    cloud.rotation.set(0, Math.random()*0.5-0.25, Math.random()*0.5-0.25);
    scene.add(cloud);
  }

  // Plateformes
  const platMat = new THREE.MeshStandardMaterial({color:0x4444ff});
  const platGeo = new THREE.BoxGeometry(3,0.5,3);
  for(let i=0;i<5;i++){
    const plat = new THREE.Mesh(platGeo, platMat.clone());
    plat.position.set(i*5, i*2+1, -i*3);
    plat.receiveShadow = true;
    plat.castShadow = true;
    scene.add(plat);
    platforms.push(plat);
  }

  // Charger Snoopy
  const loader = new GLTFLoader();
  loader.load('./models/snoopy.glb', gltf=>{
    player = gltf.scene;
    player.scale.set(0.4,0.4,0.4);
    player.position.set(0,playerHeight,0);
    player.traverse(c=>{ if(c.isMesh){ c.castShadow=true; c.receiveShadow=true; } });
    scene.add(player);
    if(gltf.animations.length>0){ mixer = new THREE.AnimationMixer(player); mixer.clipAction(gltf.animations[0]).play(); }
  });

  // Charger les Pap
  const papLoader = new GLTFLoader();
  platforms.forEach(plat => {
    papLoader.load('./models/pap.glb', gltf=>{
      const pap = gltf.scene;
      pap.scale.set(0.4,0.4,0.4);
      pap.position.set(plat.position.x, plat.position.y + 0.5, plat.position.z);
      pap.traverse(c=>{ if(c.isMesh){ c.castShadow=true; c.receiveShadow=true; } });
      scene.add(pap);
      paps.push(pap);
    });
  });

  // Clavier
  document.addEventListener('keydown', e=>{
    if(e.key==='Enter' && !gameStarted){
      gameStarted = true;
      introText.style.display='none';
    }
    if(gameStarted && keys.hasOwnProperty(e.key)) keys[e.key]=true;
    if(gameStarted && e.key===' ' && canJump){ velocityY=0.15; canJump=false; }
  });
  document.addEventListener('keyup', e=>{
    if(keys.hasOwnProperty(e.key)) keys[e.key]=false;
  });
  window.addEventListener('resize', onWindowResize);
}

function movePlayer() {
  if (!player || !gameStarted) return; // bloqué tant que Enter pas pressé

  // Déplacement horizontal
  let moved = false;
  if (keys.z) { player.position.z -= moveSpeed; moved = true; }
  if (keys.s) { player.position.z += moveSpeed; moved = true; }
  if (keys.q) { player.position.x -= moveSpeed; moved = true; }
  if (keys.d) { player.position.x += moveSpeed; moved = true; }

  // Rotation selon direction
  const dir = new THREE.Vector3(
    (keys.d ? 1 : 0) - (keys.q ? 1 : 0),
    0,
    (keys.s ? 1 : 0) - (keys.z ? 1 : 0)
  );
  if (dir.lengthSq() > 0) {
    dir.normalize();
    player.lookAt(player.position.x + dir.x, player.position.y, player.position.z + dir.z);
  }

  // Gravité
  velocityY += gravity;
  player.position.y += velocityY;

  // Collision sol et plateformes
  let maxY = playerHeight;
  canJump = false;

  platforms.forEach(plat => {
    const px = player.position.x;
    const pyFeet = player.position.y - playerHeight;
    const pz = player.position.z;
    const bx = plat.position.x;
    const by = plat.position.y + 0.25;
    const bz = plat.position.z;
    const dx = Math.abs(px - bx);
    const dz = Math.abs(pz - bz);

    if (dx < 1.5 && dz < 1.5 && velocityY <= 0) {
      if (pyFeet <= by && pyFeet + Math.abs(velocityY) >= by) {
        maxY = by + playerHeight;
        velocityY = 0;
        canJump = true;
      }
    }
  });

  if (player.position.y < maxY) {
    player.position.y = maxY;
    velocityY = 0;
    canJump = true;
  }

  // Collecte des Pap
  paps.forEach((pap, idx) => {
    if(pap && player.position.distanceTo(pap.position) < 0.8){
      scene.remove(pap);
      paps[idx] = null;
      collected++;
      papCounter.textContent = `Papillons: ${collected}`;
      if(collected === platforms.length){
  finishText.style.display = 'block';
  // Après 2 secondes, redirige vers la page niveau 3
  setTimeout(() => {
    window.location.href = 'niveau3.html';
  }, 2000);
}

    }
  });

  // Caméra suit
  const camOffset = new THREE.Vector3(0,2,5);
  const camPos = player.position.clone().add(camOffset);
  camera.position.lerp(camPos, 0.1);
  camera.lookAt(player.position);
}

function animate(){
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  if(mixer) mixer.update(delta);
  movePlayer();
  renderer.render(scene,camera);
}

function onWindowResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>
</body>
</html>
