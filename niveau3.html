<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Niveau 2 - Plateformer</title>
<style>
html, body { margin: 0; height: 100%; overflow: hidden; background: #222; font-family: sans-serif; }
#instructions {
  position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
  color: #fff; text-align: center; font-size: 16px;
}
#papCounter {
  position: absolute; top: 40px; left: 10px; color: #fff; font-size: 18px;
}
#finishText {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  color: #fff; font-size: 32px; display:none;
}
#introText {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  text-align: center; font-size: 20px; max-width: 600px;
}
</style>
</head>
<body>
<div id="finishText">Bravo, tu as fini le niveau !</div>
<div id="introText">
  Bien joué ! Maintenant récupère tous les papillons pour finir ce niveau.<br>
  <small>Appuye sur Entrée pour commencer</small>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.121.1/build/three.module.js';
import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/loaders/GLTFLoader.js';

let scene, camera, renderer, clock = new THREE.Clock();
let player, mixer;
let keys = { z:false, q:false, s:false, d:false };
let velocityY = 0, gravity = -0.005, canJump = false;
let gameStarted = false; // bloque le mouvement jusqu'à Enter

const moveSpeed = 0.08;
const playerHeight = 0.3 * 0.3; 

// Plateformes et pap
let platforms = [];
let paps = [];
let collected = 0;

const finishText = document.getElementById('finishText');
const introText = document.getElementById('introText');

init();
animate();

function init(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  // Lumières
  const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
  hemiLight.position.set(0,200,0);
  scene.add(hemiLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(100,100,100);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 2048;
  dirLight.shadow.mapSize.height = 2048;
  scene.add(dirLight);

  // Caméra
  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0,2,5);

  // Renderer
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  // Sol
  const loaderGrass = new THREE.TextureLoader();
  const groundTexture = loaderGrass.load('./textures/grass.jpg');
  groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
  groundTexture.repeat.set(20,20);
  const plane = new THREE.Mesh(
    new THREE.PlaneGeometry(100,100),
    new THREE.MeshStandardMaterial({map:groundTexture})
  );
  plane.rotation.x = -Math.PI/2;
  plane.receiveShadow = true;
  scene.add(plane);

  // Nuages
  function getRandomFloat(min, max) {
  return Math.random() * (max - min) + min;
}
  const cloudTex = loaderGrass.load('./textures/clouds.png');
  cloudTex.encoding = THREE.sRGBEncoding;
  const cloudMaterial = new THREE.MeshBasicMaterial({map:cloudTex, transparent:true, side:THREE.DoubleSide});
  for(let i=0;i<10;i++){
    const cloudGeo = new THREE.PlaneGeometry(15,8);
    const cloud = new THREE.Mesh(cloudGeo, cloudMaterial.clone());
    cloud.position.set(getRandomFloat(-100, 100),getRandomFloat(0, 20),getRandomFloat(-50, -120));
    cloud.rotation.set(0, getRandomFloat(-0.25, 0.25)*Math.PI, getRandomFloat(-0.25, 0.25)*0.2);
    scene.add(cloud);
  }

  
  // Charger Snoopy
  const loader = new GLTFLoader();
  loader.load('./models/snoopy.glb', gltf=>{
    player = gltf.scene;
    player.scale.set(0.4,0.4,0.4);
    player.position.set(0,playerHeight,0);
    player.traverse(c=>{ if(c.isMesh){ c.castShadow=true; c.receiveShadow=true; } });
    scene.add(player);
    if(gltf.animations.length>0){ mixer = new THREE.AnimationMixer(player); mixer.clipAction(gltf.animations[0]).play(); }
  });

  
  // Clavier
  document.addEventListener('keydown', e=>{
    if(e.key==='Enter' && !gameStarted){
      gameStarted = true;
      introText.style.display='none';
    }
    if(gameStarted && keys.hasOwnProperty(e.key)) keys[e.key]=true;
    if(gameStarted && e.key===' ' && canJump){ velocityY=0.15; canJump=false; }
  });
  document.addEventListener('keyup', e=>{
    if(keys.hasOwnProperty(e.key)) keys[e.key]=false;
  });
  window.addEventListener('resize', onWindowResize);
}

function movePlayer() {
  if (!player || !gameStarted) return; // bloqué tant que Enter pas pressé

  // Déplacement horizontal
  let moved = false;
  if (keys.z) { player.position.z -= moveSpeed; moved = true; }
  if (keys.s) { player.position.z += moveSpeed; moved = true; }
  if (keys.q) { player.position.x -= moveSpeed; moved = true; }
  if (keys.d) { player.position.x += moveSpeed; moved = true; }

  // Rotation selon direction
  const dir = new THREE.Vector3(
    (keys.d ? 1 : 0) - (keys.q ? 1 : 0),
    0,
    (keys.s ? 1 : 0) - (keys.z ? 1 : 0)
  );
  if (dir.lengthSq() > 0) {
    dir.normalize();
    player.lookAt(player.position.x + dir.x, player.position.y, player.position.z + dir.z);
  }

  // Gravité
  velocityY += gravity;
  player.position.y += velocityY;


  // Caméra suit
  const camOffset = new THREE.Vector3(0,2,5);
  const camPos = player.position.clone().add(camOffset);
  camera.position.lerp(camPos, 0.1);
  camera.lookAt(player.position);
}

function animate(){
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  if(mixer) mixer.update(delta);
  movePlayer();
  renderer.render(scene,camera);
}

function onWindowResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>
</body>
</html>
